<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>Spring Security REST Plugin 1.0.0.RC2</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction to the Spring Security REST plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#authentication"><strong>2</strong><span>Authentication Filter</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tokenGeneration"><strong>3</strong><span>Token Generation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tokenStorage"><strong>4</strong><span>Token Storage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tokenValidation"><strong>5</strong><span>Token Validation Filter</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p>Implements authentication for REST APIs based on Spring Security. It uses a token-based workflow</p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>Spring Security REST Plugin - Reference Documentation</h1>
                            <p><strong>Authors:</strong> Alvaro Sanchez-Mariscal</p>
                            <p><strong>Version:</strong> 1.0.0.RC2</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction to the Spring Security REST plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#authentication"><strong>2</strong><span>Authentication Filter</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tokenGeneration"><strong>3</strong><span>Token Generation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tokenStorage"><strong>4</strong><span>Token Storage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#memcached"><strong>4.1</strong><span>Memcached</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gorm"><strong>4.2</strong><span>GORM</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tokenValidation"><strong>5</strong><span>Token Validation Filter</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        

<h1 id="introduction">1 Introduction to the Spring Security REST plugin</h1>
The Spring Security REST Grails plugin allows you to use Spring Security for a stateless, token-based, RESTful authentication.<p class="paragraph"/>The default behaviour of Spring Security is to store the authenticated principal in the HTTP session. However, in a
RESTful scenario, we need to make sure our server is stateless.<p class="paragraph"/>If you are writing an API that will be used by other programs, you can use OAuth for this. But if you are exposing your API
for a front-end Javascript client to implement a
<a href="http://www.slideshare.net/alvarosanchezmariscal/developing-spi-applications-using-grails-and-angularjs" target="blank">Single Page Interface</a>,
OAuth is not an option, specially if you want to authentication end users against your own user backend (eg: LDAP). In
this case, a token-based authentication may be a more suitable implementation, like the following:<p class="paragraph"/><img border="0" class="center" src="../img/rest.png"></img>
<ol>
<li>The client application requests and endpoint that requires authentication, so the server responds with a 401 response.</li>
<li>The client redirects the user to the login form.</li>
<li>The user enter credentials, and the client sends a request to the authentication endpoint. The server validates credentials, and if valid, generates, stores and sends back a token to the client.</li>
<li>The client then stores the token internally. It will be sent on every API method request.</li>
<li>The client sends again a request to the protected resource, passing the token as an HTTP header.</li>
<li>The server validates the token, and if valid, executes the actual operation requested.</li>
</ol><p class="paragraph"/>As per the <a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="blank">REST definition</a>, the client is transferring its
state on every request so the server is truly stateless. The approach to store tokens on the server is just an alternative
to use HTTP basic authentication (so credentials are not passed on every request). It also helps to perform the validation
step (#5 in the diagram) faster, because the tokens, and the associated principal information may be cached. Finally,
storing tokens gives you the chance to decide about expiration strategies.<p class="paragraph"/>More information about this strategy can be found <a href="http://www.jamesward.com/2013/05/13/securing-single-page-apps-and-rest-services" target="blank">on this post by James Ward</a>.<p class="paragraph"/>This plugin helps you to wire your existing Spring Security <a href="../guide/single.html#authentication" class="guide">authentication mechanism</a>, provides you
with ready-to-use <a href="../guide/single.html#tokenGeneration" class="guide">token generation strategies</a> and comes prepackaged with Memcached and GORM support
for <a href="../guide/single.html#tokenStorage" class="guide">token storage</a>.<p class="paragraph"/><h4>Release History</h4>
<ul class="star">
<li>10 January 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=3" target="blank">GitHub issues</a></li>
</ul>
<li>31 December 2013</li>
<ul class="star">
<li>Initial 1.0.0.RC1 release.</li>
</ul></ul><p class="paragraph"/><h2>Getting started</h2><p class="paragraph"/>To use this plugin, add this to the <code>BuildConfig.groovy</code> file:<p class="paragraph"/><div class="code"><pre>compile ':spring&#45;security&#45;<span class="java&#45;keyword">rest</span>:1.0.0.RC2'</pre></div>


<h1 id="authentication">2 Authentication Filter</h1>
The <a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/RestAuthenticationFilter.html" target="blank">authentication filter</a>
uses the default <code>authenticationManager</code> bean, which in turn uses all the registered authentication
providers. See the <a href="http://grails-plugins.github.io/grails-spring-security-core/docs/manual/guide/authenticationProviders.html" target="blank">Spring Security Core guide</a>
for more information about how to define your own providers. Note that you can easily plug any Spring Security sub-plugin
(like the LDAP one) to use a different authentication strategy.<p class="paragraph"/>If the authentication is successful, a <a href="../guide/single.html#tokenGeneration" class="guide">token generator</a> is used to generate a token, and a
<a href="../guide/single.html#tokenStorage" class="guide">token storage</a> implementation is used to store the token.<p class="paragraph"/>Finally, the JSON response sent back to the client is rendered by a <code>restAuthenticationTokenJsonRenderer</code> bean. The plugin
offers you a <a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/rendering/DefaultRestAuthenticationTokenJsonRenderer.html" target="blank">default implementation</a>
that renders a response like this:<p class="paragraph"/><div class="code"><pre>&#123;
    <span class="java&#45;quote">"username"</span>: <span class="java&#45;quote">"john.doe"</span>,
    <span class="java&#45;quote">"token"</span>: <span class="java&#45;quote">"1a2b3c4d"</span>,
    <span class="java&#45;quote">"roles"</span>: &#91;
        <span class="java&#45;quote">"ADMIN"</span>,
        <span class="java&#45;quote">"USER"</span>
    &#93;
&#125;</pre></div><p class="paragraph"/>If you want your own, simply create a class implementing
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/rendering/RestAuthenticationTokenJsonRenderer.html" target="blank">RestAuthenticationTokenJsonRenderer</a>
and wire it up in <code>resources.groovy</code> with name <code>restAuthenticationTokenJsonRenderer</code>.<p class="paragraph"/><blockquote class="note">
The <code>UserDetails</code> object stored in the security context, and passed to the JSON renderer, is coming from the configured
<code>userDetailsService</code> bean. If you want to render additional information in your JSON response, you have to:
<ol>
<li>Configure an alternative <code>userDetailsService</code> bean that retrieves the additional information you want, and put it in a <code>UserDetails</code> object.</li>
<li>Configure an alternative <code>restAuthenticationTokenJsonRenderer</code> that reads that information from the <code>restAuthenticationToken.principal</code> object.</li>
</ol><p class="paragraph"/></blockquote><p class="paragraph"/>The following are the <code>Config.groovy</code> properties available:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.endpointUrl</code></td><td><code>/login</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.login.failureStatusCode</code></td><td><code>403</code></td></tr></table><p class="paragraph"/><h2>Extracting credentials from the request</h2><p class="paragraph"/>The plugin supports 2 ways of extracting the username and password: using request parameters, and using a JSON payload.
For backwards compatibility, request parameters is the default option.<p class="paragraph"/><h3>From request parameters</h3><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.useRequestParamsCredentials</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.login.usernameParameter</code></td><td><code>username</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.passwordParameter</code></td><td><code>password</code></td></tr></table><p class="paragraph"/><h3>From a JSON request</h3><p class="paragraph"/>To enable it:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.useJsonCredentials</code></td><td><code>true</code></td></tr></table><p class="paragraph"/>
The default implementation expects a request like this:<p class="paragraph"/><div class="code"><pre>&#123;
    <span class="java&#45;quote">"username"</span>: <span class="java&#45;quote">"john.doe"</span>,
    <span class="java&#45;quote">"password"</span>: <span class="java&#45;quote">"dontTellAnybody"</span>
&#125;</pre></div><p class="paragraph"/>If your JSON request format is different, you can plug your own implementation by defining a class which extends
<code><a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/AbstractJsonPayloadCredentialsExtractor.html" target="blank">AbstractJsonPayloadCredentialsExtractor</a></code>.
The default implementation looks like this:<p class="paragraph"/><div class="code"><pre>@Log4j
class DefaultJsonPayloadCredentialsExtractor <span class="java&#45;keyword">extends</span> AbstractJsonPayloadCredentialsExtractor &#123;<p class="paragraph"/>    UsernamePasswordAuthenticationToken extractCredentials(HttpServletRequest httpServletRequest) &#123;
        def jsonBody = getJsonBody(httpServletRequest)<p class="paragraph"/>        log.debug <span class="java&#45;quote">"Extracted credentials from request params. Username: $&#123;jsonBody.username&#125;, password: $&#123;jsonBody.password?.size()?'&#91;PROTECTED&#93;':'&#91;MISSING&#93;'&#125;"</span><p class="paragraph"/>        <span class="java&#45;keyword">new</span> UsernamePasswordAuthenticationToken(jsonBody.username, jsonBody.password)
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Once you are done, register it in <code>resources.groovy</code> with the name <code>credentialsExtractor</code>.<p class="paragraph"/>


<h1 id="tokenGeneration">3 Token Generation</h1>
The plugin comes prepackaged with 2 token generation strategies:
<ul class="star">
<li><a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/generation/SecureRandomTokenGenerator.html" target="blank">Using java.security.SecureRandom</a>.</li>
<li><a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/generation/UUIDTokenGenerator.html" target="blank">Using java.util.UUID</a>.</li>
</ul><p class="paragraph"/>The strategy used is configurable in <code>Config.groovy</code>:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.generation.useSecureRandom</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.generation.useUUID</code></td><td><code>false</code></td></tr></table><p class="paragraph"/>Both of them generate tokens of 32 alphanumeric characters.<p class="paragraph"/>That should be enough for most of the human beings. But if you still want to provide your own implementation,
simply write a class implementing
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/generation/TokenGenerator.html" target="blank">TokenGenerator</a>
and wire it up in <code>resources.groovy</code> as <code>tokenGenerator</code>.


<h1 id="tokenStorage">4 Token Storage</h1>
The tokens are stored on the server using a <code>tokenStorageService</code> bean. The plugin comes with out-of-the-box support
for Memcached and GORM, but you can use your own strategy implementing the
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/storage/TokenStorageService.html" target="blank">TokenStorageService</a>
interface.


<h2 id="memcached">4.1 Memcached</h2>
To use Memcached, simply define the following configuration properties to match your environments accordingly:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useMemcached</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.hosts</code></td><td><code>localhost:11211</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.username</code></td><td><code>''</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.password</code></td><td><code>''</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.expiration</code></td><td><code>3600</code></td></tr></table><p class="paragraph"/>For development, if you have Memcached installed locally with the default settings, just define
<code>grails.plugin.springsecurity.rest.token.storage.useMemcached = true</code>. It should work.


<h2 id="gorm">4.2 GORM</h2>
<blockquote class="warning">
The GORM support is still experimental.
</blockquote><p class="paragraph"/>To use GORM, those are the relevant configuration properties:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useGorm</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.tokenDomainClassName</code></td><td><code>AuthenticationToken</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.tokenValuePropertyName</code></td><td><code>tokenValue</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.usernamePropertyName</code></td><td><code>username</code></td></tr></table><p class="paragraph"/>The domain class should look like this:<p class="paragraph"/><div class="code"><pre>class AuthenticationToken &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> tokenValue
    <span class="java&#45;object">String</span> username
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
In this case, instead of storing the whole <code>UserDetails</code> object, only the username is stored. This is because applications
using this strategy will probably have the standard User and Role domain classes. Then, the username is passed to the
default <code>userDetailsService</code> bean, which in the case of the default Spring Security Core GORM implementation will fetch
the information from the mentioned domain classes.
</blockquote>


<h1 id="tokenValidation">5 Token Validation Filter</h1>
The token validation filter looks for the token in a HTTP header and then tries to validate the token using the configured
<a href="../guide/single.html#tokenStorage" class="guide">token storage</a> implementation.<p class="paragraph"/>If the validation is successful, the UserDetails object is stored in the security context. This allows you to use in
your application <code>&#64;Secured</code>, <code>springSecurityService.principal</code> and so on.<p class="paragraph"/><blockquote class="note">
<code>springSecurityService.currentUser</code> expects a <code>grails.plugin.springsecurity.userdetails.GrailsUser</code> to perform a DB query.
However, this plugins stores in the security context a more generic <code>org.springframework.security.core.userdetails.User</code>
because it does not assume you are using domain classes to store the users.
Use <code>springSecurityService.principal</code> instead.
</blockquote><p class="paragraph"/>The configuration properties are:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.validation.headerName</code></td><td><code>X-Auth-Token</code></td></tr></table>

                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>

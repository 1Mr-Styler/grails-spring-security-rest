<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>8 Token Storage 1.5.2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <ul>
        <li>
            <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                <a href="../guide/index.html" class="button">Table of contents</a>

                <div id="nav-summary-childs" style="display:none;">
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/introduction.html"><strong>1</strong><span>Introduction to the Spring Security REST plugin</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/whatsNew15.html"><strong>2</strong><span>What's new in 1.5?</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/whatsNew14.html"><strong>3</strong><span>What's new in 1.4?</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/configuration.html"><strong>4</strong><span>Configuration</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/events.html"><strong>5</strong><span>Events</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/authentication.html"><strong>6</strong><span>Authentication Endpoint</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/tokenGeneration.html"><strong>7</strong><span>Token Generation</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/tokenStorage.html"><strong>8</strong><span>Token Storage</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/tokenRendering.html"><strong>9</strong><span>Token Rendering</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/tokenValidation.html"><strong>10</strong><span>Token Validation Filter</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/cors.html"><strong>11</strong><span>CORS support</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/oauth.html"><strong>12</strong><span>Delegating authentication to OAuth providers</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/debugging.html"><strong>13</strong><span>Debugging</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/faq.html"><strong>14</strong><span>Frequently Asked Questions</span></a>
                    </div>
                    
                </div>
            </div>
        </li>
        <li class="separator selected">
            <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
        </li>
    </ul>
</div>
<div id="header">
    <div class="images clearfix">
        
        
    </div>
    <p>Implements authentication for REST APIs based on Spring Security. It uses a token-based workflow</p>
</div>


<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/tokenGeneration.html">&lt;&lt; <strong>7</strong><span>Token Generation</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/tokenRendering.html"><strong>9</strong><span>Token Rendering</span> >></a></div>
                


                <div class="project">
                    <h1>8 Token Storage - Reference Documentation</h1>

                    <p><strong>Authors:</strong> Alvaro Sanchez-Mariscal</p>

                    <p><strong>Version:</strong> 1.5.2</p>

                    
                </div>

                
                <div id="table-of-content">
                    <h2>Table of Contents</h2>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#jwt"><strong>8.1</strong><span>JSON Web Token</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#memcached"><strong>8.2</strong><span>Memcached</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#gorm"><strong>8.3</strong><span>GORM</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#redis"><strong>8.4</strong><span>Redis</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#grailsCache"><strong>8.5</strong><span>Grails Cache</span></a>
                    </div>
                    
                </div>
                

                

<h1 id="tokenStorage">8 Token Storage</h1>
The tokens are stored on the server using a <code>tokenStorageService</code> bean. The plugin comes with out-of-the-box support
for JWT, Memcached, GORM and <a href="http://grails.org/plugin/cache" target="blank">Grails Cache</a>, but you can use your own strategy implementing the
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/latest/docs/gapi/grails/plugin/springsecurity/rest/token/storage/TokenStorageService.html" target="blank">TokenStorageService</a>
interface.<p class="paragraph"/><blockquote class="note">
The default implementation, <a href="../guide/single.html#jwt" class="guide">JWT</a>, is stateless. Nothing is really stored. However, the plugin still gives a
chance to the other implementations to store the principal if they need to.
</blockquote>


<h2 id="jwt">8.1 JSON Web Token</h2>
JSON Web Token (JWT) is an <a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token" target="blank">IETF standard</a> (in progress)
which defines a secure way to encapsulate arbitrary data that can be sent over unsecure URL's.<p class="paragraph"/>Generally speaking, JWT's can be useful in the following use cases:
<ul class="star">
<li>When generating "one click" action emails, like "delete this comment" or "add this to favorites". Instead of giving the users URL's like <code>/comment/delete/123</code>, you can give them something like <code>/comment/delete/&#60;JWT_TOKEN&#62;</code>, where the <code>JWT_TOKEN</code> contains encapsulated information about the user and the comment, in a safe way, so authentication is not required.</li>
<li>To achieve single sign-on, by sharing a JWT across applications.</li>
</ul><p class="paragraph"/>In the context of authentication and authorization, JWT will help you implement a stateless implementation, as the
principal information is stored directly in the JWT.<p class="paragraph"/><h2>How does a JWT looks like?</h2><p class="paragraph"/><img border="0" class="center" src="../img/jwt.png"></img><p class="paragraph"/><h3>Header</h3><p class="paragraph"/>A base64-encoded JSON like:<p class="paragraph"/><div class="code"><pre>&#123;
    <span class="java&#45;quote">"alg"</span>: <span class="java&#45;quote">"HS256"</span>,
    <span class="java&#45;quote">"typ"</span>: <span class="java&#45;quote">"JWT"</span>
&#125;</pre></div><p class="paragraph"/><h3>Claims</h3><p class="paragraph"/>A base64-encoded JSON like:<p class="paragraph"/><div class="code"><pre>&#123;
    <span class="java&#45;quote">"exp"</span>: 1422990129,
    <span class="java&#45;quote">"sub"</span>: <span class="java&#45;quote">"jimi"</span>,
    <span class="java&#45;quote">"roles"</span>: &#91;
        <span class="java&#45;quote">"ROLE_ADMIN"</span>,
        <span class="java&#45;quote">"ROLE_USER"</span>
    &#93;,
    <span class="java&#45;quote">"iat"</span>: 1422986529
&#125;</pre></div><p class="paragraph"/><h3>Signature</h3><p class="paragraph"/>Depends on the algorithm specified on the header, it can be a digital signature of the base64-encoded header and claims,
or an encryption of them using RSA.<p class="paragraph"/><h2>Signed JWT's</h2><p class="paragraph"/>By default, this plugin uses signed JWT's as specified by the
<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-signature" target="blank">JSON Web Signature</a> specification. More specifically,
the algorithm used is HMAC SHA-256 with a specified shared secret. The relevant configuration properties are:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useJwt</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.jwt.useSignedJwt</code></td><td><code>true</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.jwt.secret</code></td><td><code>'qrD6h8K6S9503Q06Y6Rfk21TErImPYqa'</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.jwt.expiration</code></td><td><code>3600</code></td></tr></table><p class="paragraph"/><h2>Encrypted JWT's</h2><p class="paragraph"/><blockquote class="note">
Grails's <code>grails-docs</code> artifact includes a version of <code>com.lowagie:itext</code> which in turns bring old BouncyCastle's libraries
into the classpath. To avoid the problem, you have to override explicitly that dependency:<p class="paragraph"/><div class="code"><pre>build(<span class="java&#45;quote">"com.lowagie:itext:2.0.8"</span>) &#123; excludes <span class="java&#45;quote">"bouncycastle:bcprov&#45;jdk14:138"</span>, <span class="java&#45;quote">"org.bouncycastle:bcprov&#45;jdk14:1.38"</span> &#125;</pre></div>
</blockquote><p class="paragraph"/>In the previous strategy, the claims are just signed, so it prevents an attacker to tamper its contents to introduce
malicious data or try a privilege escalation by adding more roles. However, the claims can be decoded just by using
Base 64.<p class="paragraph"/>If the claims contains sensitive information, you can use a
<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-encryption" target="blank">JSON Web Encryption</a> algorithm to prevent them to be decoded.
Particularly, this plugin uses RSAES OAEP for key encryption and AES GCM (Galois/Counter Mode) algorithm with a 256 bit key
for content encryption.<p class="paragraph"/>By default, RSA public/private keys ar generated every time the application runs. This means that  generated tokens
won't be decrypted across executions of the application. So better create your own key pair using OpenSSL:<p class="paragraph"/><div class="code"><pre>openssl genrsa &#45;out private_key.pem 2048
openssl pkcs8 &#45;topk8 &#45;inform PEM &#45;outform DER &#45;in private_key.pem &#45;out private_key.der &#45;nocrypt
openssl rsa &#45;in private_key.pem &#45;pubout &#45;outform DER &#45;out public_key.der</pre></div><p class="paragraph"/>Then, configure the keys properly, along with the rest of the configuration:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useJwt</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.jwt.useEncryptedJwt</code></td><td><code>false</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.jwt.privateKeyPath</code></td><td><code>null</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.jwt.publicKeyPath</code></td><td><code>null</code></td></tr></table><p class="paragraph"/>Example configuration:<p class="paragraph"/><div class="code"><pre>grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.token.storage.jwt.useEncryptedJwt = <span class="java&#45;keyword">true</span>
grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.token.storage.jwt.privateKeyPath = '/path/to/private_key.der'
grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.token.storage.jwt.publicKeyPath = '/path/to/public_key.der'</pre></div><p class="paragraph"/><blockquote class="warning">
The performance of encryption algorithms is much slower compared with signing ones. If you are considering encrypting
you JWT's, think if you really need it.
</blockquote><p class="paragraph"/><h2>Token expiration and refresh tokens</h2><p class="paragraph"/>When using JWT, issued access tokens expire after a period of time, and they are paired with refresh tokens, eg:<p class="paragraph"/><div class="code"><pre>&#123;
   <span class="java&#45;quote">"username"</span>: <span class="java&#45;quote">"jimi"</span>,
   <span class="java&#45;quote">"roles"</span>: &#91;
      <span class="java&#45;quote">"ROLE_ADMIN"</span>,
      <span class="java&#45;quote">"ROLE_USER"</span>
   &#93;,
   <span class="java&#45;quote">"expires_in"</span>: 3600,
   <span class="java&#45;quote">"token_type"</span>: <span class="java&#45;quote">"Bearer"</span>,
   <span class="java&#45;quote">"refresh_token"</span>: <span class="java&#45;quote">"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.fUaSWIdZakFX7CyimRIPhuw0sfevgmwL2xzm5H0TuaqwKx24EafCO0TruGKG&#45;lN&#45;wGCITssnF2LQTqRzQGp0PoLXHfUJ0kkz5rBl6LtnRu7cdD1ZUNYXLJtFjQ3IATzoo15tPafRPyStG1Qm7&#45;1L0VxquhrLxkkpti0F1_VTytZAq8ltFrnxM4ahJUwS7eriivvdLqmHtnwuXw0kBXEseIyCkiyKklWDJAcD_P_gHoQJvSCoXedlr7Pp0n6LEUrRWJ2Hb&#45;Zyt9dWqWDxm9nyDeEVtEZGcQtpgCGgbXxaUpULIy5nvrbRzXSNyT6iXhK1CLqiFVkfh&#45;Y&#45;DHXdB6Q4sg.uYdpxl835KnlkqC5.gBgSnPWZOo6FINovJNG7Xx2RuS09QJbU4&#45;_J4EgZQkygt8xE&#45;HfdYaOmtmJLjGJR1XKoaRsuX1gNjFoCZgqWAon6.Zsrk52dkjskSVQLXZBQooQ"</span>,
   <span class="java&#45;quote">"access_token"</span>: <span class="java&#45;quote">"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.n&#45;gGe65x0SlSXS3fTG8ZLdXvv6b5_1pDvkcGyCjFy&#45;vm1VhaBEQL5p3hc6iUcCAcuyrqzGk95lV9dHCv46cNfCiUFHWfbEcd4nqScIxBbc28xO9L1mNLnZ0G1rx1Mx1L0Y_ZPoSxDXpJaHCT28cdZffHLxx2B9ioIClgdlYBAJ5Oz8VT39&#45;D0QSomS6QhFqmcpbDsXrsKxs545Pn&#45;TIlu&#45;fSQ4wpIvAxusOKB6CV2EYKqBplMBrh&#45;3btE8WksVcX2N3LsrcMhrKxSKi93c06MZh6JzSLWe5bl9hvUvBdEuwDrk&#45;fQgD3ZlmjjoevRWYhv_kslW1PlqUHYmKOQ7csUw.3mvvsFWikEjZzExA.YixjnnzzcPRy_uUpgPv5zqOfshv3pUwfrME0AijpsB7u9CmJe94g6f2y_3vqUps&#45;5weKKGZyk3ZtnwEbPVAk9&#45;HZt&#45;Y27SbZl4JNCFEOLVsMsK8.h4j9BdFXuWKKez6xxRAwJA"</span>
&#125;</pre></div><p class="paragraph"/>Refresh tokens never expire, and can be used to obtain a new access token by sending a POST request to the
<code>/oauth/access_token</code> endpoint:<p class="paragraph"/><div class="code"><pre>POST /myApp/oauth/access_token HTTP/1.1
Host: server.example.com
Content&#45;Type: application/x&#45;www&#45;form&#45;urlencoded<p class="paragraph"/>grant_type=refresh_token&#38;refresh_token=eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ....</pre></div><p class="paragraph"/>As you can see, is a form request with 2 parameters:
<ul class="star">
<li><code>grant_type</code>: must be <code>refres_token</code> always.</li>
<li><code>refresh_token</code>: the refresh token provided earlier.</li>
</ul><p class="paragraph"/><blockquote class="note">
As refresh tokens never expire, they must be securely stored in your client application. See
<a href="https://tools.ietf.org/html/rfc6749#section-10.4" target="blank">section 10.4 of the OAuth 2.0 spec</a> for more information.
</blockquote>


<h2 id="memcached">8.2 Memcached</h2>
To use Memcached, simply define the following configuration properties to match your environments accordingly:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useMemcached</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.hosts</code></td><td><code>localhost:11211</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.username</code></td><td><code>''</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.password</code></td><td><code>''</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.expiration</code></td><td><code>3600</code></td></tr></table><p class="paragraph"/>For development, if you have Memcached installed locally with the default settings, just define
<code>grails.plugin.springsecurity.rest.token.storage.useMemcached = true</code>. It should work.<p class="paragraph"/>In Memcached tokens will expire automatically after the configured timeout (1h by default).
They get refreshed on every access



<h2 id="gorm">8.3 GORM</h2>
To use GORM, these are the relevant configuration properties:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useGorm</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.tokenDomainClassName</code></td><td><code>null</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.tokenValuePropertyName</code></td><td><code>tokenValue</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.usernamePropertyName</code></td><td><code>username</code></td></tr></table><p class="paragraph"/>The relevant domain class should look something like this:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.example.product<p class="paragraph"/>class AuthenticationToken &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> tokenValue
    <span class="java&#45;object">String</span> username<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
        version <span class="java&#45;keyword">false</span>
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
For the <code>tokenDomainClassName</code> configuration you must enter a fully qualified class name. In the case of the example above:
<code>grails.plugin.springsecurity.rest.token.storage.gorm.tokenDomainClassName = 'org.example.product.AuthenticationToken'</code>
</blockquote><p class="paragraph"/>A few things to take into consideration when using GORM for token storage:
<ul class="star">
<li>Instead of storing the whole <code>UserDetails</code> object, probably only the username is needed. This is because applications</li>
</ul><p class="paragraph"/>using this strategy will probably have the standard User and Role domain classes. When the token is verified the username
is passed to the default <code>userDetailsService</code> bean, which in the case of the default Spring Security Core GORM
implementation will fetch the information from the mentioned domain classes.
<ul class="star">
<li>GORM's optimistic locking feature is likely unnecessary and may cause performance issues.</li>
<li>You'll have to handle token expiration by yourself via Quartz jobs or a similar mechanism. There are various ways you might</li>
</ul><p class="paragraph"/>go about this.<p class="paragraph"/><strong class="bold">GORM Token Expiration Examples:</strong><p class="paragraph"/>Adding a GORM autoTimestamp property like <code>lastUpdated</code> or <code>dateCreated</code> and sorting out stale or old tokens with Quartz jobs
are the most obvious routes. Each has its drawbacks though.<p class="paragraph"/><code>dateCreated</code> is useful if you want tokens to expire a set time after they are issued. However, API users who didn't pay
attention to when their token was issued may find themselves needing a new token unexpectedly.<p class="paragraph"/><div class="code"><pre>Date dateCreated</pre></div><p class="paragraph"/>
<code>lastUpdated</code> requires a change to the token domain instance in order to be triggered. Something as simple as an access
counter may work as a strategy to keepTokens fresh, but doing a write to a disk based database on each token access may
be something you would prefer to avoid for the sake of performance.<p class="paragraph"/><div class="code"><pre>Date lastUpdated
    <span class="java&#45;object">Integer</span> accessCount = 0<p class="paragraph"/>    def afterLoad() &#123;
      accessCount++
   &#125;</pre></div><p class="paragraph"/>Simply using your own date or timestamp is also a valid option.<p class="paragraph"/><div class="code"><pre>Date refreshed = <span class="java&#45;keyword">new</span> Date()<p class="paragraph"/>    def afterLoad() &#123;
        // <span class="java&#45;keyword">if</span> being accessed and it is more than a day since last marked as refreshed
        // and it hasn't been wiped out by Quartz job (it exists, duh)
        // then refresh it
        <span class="java&#45;keyword">if</span> (refreshed &#60; <span class="java&#45;keyword">new</span> Date() &#45;1) &#123;
            refreshed = <span class="java&#45;keyword">new</span> Date()
            it.save()
        &#125;
    &#125;</pre></div><p class="paragraph"/>Here is an example quartz job to go with the custom refresh timestamp above:<p class="paragraph"/><div class="code"><pre>class RemoveStaleTokensJob &#123;
    <span class="java&#45;keyword">static</span> triggers = &#123;
        cron name: 'every4hours', cronExpression: '0 0 &#42;/4 &#42; &#42; &#42;'
    &#125;<p class="paragraph"/>    void execute() &#123;
        AuthenticationToken.executeUpdate('delete AuthenticationToken a where a.refreshed &#60; ?' &#91;<span class="java&#45;keyword">new</span> Date()&#45;1&#93;)
    &#125;
&#125;</pre></div>



<h2 id="redis">8.4 Redis</h2>
To use Redis as a token store simply you just have to enable it in you configuration by setting <code>useRedis</code> to <code>true</code>
(see table below).<p class="paragraph"/>You have to have the <code>redis</code> plugin installed in order to be able to use Redis as your token store. Refer to the
<a href="https://github.com/grails-plugins/grails-redis" target="blank">Redis plugin documentation</a> for more details about how to configure it.<p class="paragraph"/>Configuration options for Redis:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useRedis</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.redis.expiration</code></td><td><code>3600</code></td></tr></table><p class="paragraph"/>


<h2 id="grailsCache">8.5 Grails Cache</h2>
To use <a href="http://grails.org/plugin/cache" target="blank">Grails Cache</a>, simply define a cache name:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useGrailsCache</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.grailsCacheName</code></td><td><code>null</code></td></tr></table><p class="paragraph"/>The cache name should correspond to a name specified in the <a href="http://grails-plugins.github.io/grails-cache/docs/manual/guide/usage.html#dsl" target="blank">cache DSL</a>.<p class="paragraph"/><blockquote class="note">
<strong class="bold">Token expiration / eviction / TTL</strong><p class="paragraph"/>By default, Spring Cache abstraction
<a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/cache.html#cache-specific-config" target="blank">does not support expiration</a>.
It depends on the specific support of the actual providers. Grails has several plugins for this:
<ul class="star">
<li><a href="http://grails-plugins.github.io/grails-cache/guide/usage.html#dsl" target="blank">Core</a>: unsupported.</li>
<li><a href="http://grails-plugins.github.io/grails-cache-ehcache/guide/usage.html#dsl" target="blank">Ehcache</a>: supported.</li>
<li><a href="http://grails-plugins.github.io/grails-cache-redis/guide/usage.html#dsl" target="blank">Redis</a>: unsupported.</li>
<li><a href="http://grails.org/plugin/cache-gemfire" target="blank">Gemfire</a>: unsupported.</li>
</ul><p class="paragraph"/></blockquote><p class="paragraph"/><blockquote class="warning">
There is a bug in <code>:cache-ehcache:1.0.0</code> plugin that will cause issues. It's recommended that you use the latest version.
See <a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues/89" target="blank">#89</a> for more information.
</blockquote>


                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/tokenGeneration.html">&lt;&lt; <strong>7</strong><span>Token Generation</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/tokenRendering.html"><strong>9</strong><span>Token Rendering</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>Spring Security REST Plugin 1.4.0</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction to the Spring Security REST plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#whatsNew14"><strong>2</strong><span>What's new in 1.4?</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#configuration"><strong>3</strong><span>Configuration</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#authentication"><strong>4</strong><span>Authentication Endpoint</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tokenGeneration"><strong>5</strong><span>Token Generation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tokenStorage"><strong>6</strong><span>Token Storage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tokenRendering"><strong>7</strong><span>Token Rendering</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tokenValidation"><strong>8</strong><span>Token Validation Filter</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#cors"><strong>9</strong><span>CORS support</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#oauth"><strong>10</strong><span>Delegating authentication to OAuth providers</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#debugging"><strong>11</strong><span>Debugging</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#faq"><strong>12</strong><span>Frequently Asked Questions</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p>Implements authentication for REST APIs based on Spring Security. It uses a token-based workflow</p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>Spring Security REST Plugin - Reference Documentation</h1>
                            <p><strong>Authors:</strong> Alvaro Sanchez-Mariscal</p>
                            <p><strong>Version:</strong> 1.4.0</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction to the Spring Security REST plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#whatsNew14"><strong>2</strong><span>What's new in 1.4?</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#configuration"><strong>3</strong><span>Configuration</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#authentication"><strong>4</strong><span>Authentication Endpoint</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#logout"><strong>4.1</strong><span>Logout Endpoint</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tokenGeneration"><strong>5</strong><span>Token Generation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tokenStorage"><strong>6</strong><span>Token Storage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#memcached"><strong>6.1</strong><span>Memcached</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gorm"><strong>6.2</strong><span>GORM</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#grailsCache"><strong>6.3</strong><span>Grails Cache</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tokenRendering"><strong>7</strong><span>Token Rendering</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tokenValidation"><strong>8</strong><span>Token Validation Filter</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#cors"><strong>9</strong><span>CORS support</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#oauth"><strong>10</strong><span>Delegating authentication to OAuth providers</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#google"><strong>10.1</strong><span>Google</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#facebook"><strong>10.2</strong><span>Facebook</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#twitter"><strong>10.3</strong><span>Twitter</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#debugging"><strong>11</strong><span>Debugging</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#faq"><strong>12</strong><span>Frequently Asked Questions</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        

<h1 id="introduction">1 Introduction to the Spring Security REST plugin</h1>
The Spring Security REST Grails plugin allows you to use Spring Security for a stateless, token-based, RESTful authentication.<p class="paragraph"/><blockquote class="note">
This plugin depends on <a href="http://grails-plugins.github.io/grails-spring-security-core/docs/manual/guide/newInV2.html" target="blank">Spring Security Core 2.x</a>.
Make sure your application is compatible with that version first. There is a
<a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues/15" target="blank">feature request</a>, that may be addressed in the
future if there is enough community interest / love :)
</blockquote><p class="paragraph"/>The default behaviour of Spring Security is to store the authenticated principal in the HTTP session. However, in a
RESTful scenario, we need to make sure our server is stateless.<p class="paragraph"/>If you are writing an API that will be used by other programs, you can use OAuth for this. But if you are exposing your API
for a front-end Javascript client to implement a
<a href="http://www.slideshare.net/alvarosanchezmariscal/developing-spi-applications-using-grails-and-angularjs" target="blank">Single Page Interface</a>,
OAuth is not an option, specially if you want to authentication end users against your own user backend (eg: LDAP). In
this case, a token-based authentication may be a more suitable implementation, like the following:<p class="paragraph"/><img border="0" class="center" src="../img/rest.png"></img>
<ol>
<li>The client application requests and endpoint that requires authentication, so the server responds with a 401 response.</li>
<li>The client redirects the user to the login form.</li>
<li>The user enter credentials, and the client sends a request to the authentication endpoint. The server validates credentials, and if valid, generates, stores and sends back a token to the client.</li>
<li>The client then stores the token internally. It will be sent on every API method request.</li>
<li>The client sends again a request to the protected resource, passing the token as an HTTP header.</li>
<li>The server validates the token, and if valid, executes the actual operation requested.</li>
</ol><p class="paragraph"/>As per the <a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="blank">REST definition</a>, the client is transferring its
state on every request so the server is truly stateless. The approach to store tokens on the server is just an alternative
to use HTTP basic authentication (<a href="../guide/single.html#faq" class="guide">see FAQ</a>) (so credentials are not passed on every request). It also helps to perform the validation
step (#5 in the diagram) faster, because the tokens, and the associated principal information may be cached. Finally,
storing tokens gives you the chance to decide about expiration strategies.<p class="paragraph"/>More information about this strategy can be found <a href="http://www.jamesward.com/2013/05/13/securing-single-page-apps-and-rest-services" target="blank">on this post by James Ward</a>.<p class="paragraph"/>This plugin helps you to wire your existing Spring Security <a href="../guide/single.html#authentication" class="guide">authentication mechanism</a>, provides you
with ready-to-use <a href="../guide/single.html#tokenGeneration" class="guide">token generation strategies</a> and comes prepackaged with Memcached, GORM and Grails
Cache support for <a href="../guide/single.html#tokenStorage" class="guide">token storage</a>.<p class="paragraph"/><h4>Release History</h4>
<ul class="star">
<li>12 August 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?q=milestone%3A1.4.0+is%3Aclosed" target="blank">1.4.0</a></li>
</ul>
<li>14 July 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=22&amp;state=closed" target="blank">1.4.0.RC5</a></li>
</ul>
<li>4 July 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=21&amp;state=closed" target="blank">1.4.0.RC4</a></li>
</ul>
<li>24 June 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=19&amp;state=closed" target="blank">1.4.0.RC3</a></li>
</ul>
<li>24 June 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=18&amp;state=closed" target="blank">1.4.0.RC2</a></li>
</ul>
<li>20 June 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=17&amp;state=closed" target="blank">1.4.0.RC1</a></li>
</ul>
<li>11 June 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=16&amp;state=closed" target="blank">1.4.0.M3</a></li>
</ul>
<li>1 June 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=15&amp;state=closed" target="blank">1.4.0.M2</a></li>
</ul>
<li>29 May 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=14&amp;state=closed" target="blank">1.4.0.M1</a></li>
</ul>
<li>23 April 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=13&amp;state=closed" target="blank">1.3.4</a></li>
</ul>
<li>16 April 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=12&amp;state=closed" target="blank">1.3.3</a></li>
</ul>
<li>3 April 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=11&amp;state=closed" target="blank">1.3.2</a></li>
</ul>
<li>18 March 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=10&amp;state=closed" target="blank">1.3.1</a></li>
</ul>
<li>4 March 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=9&amp;state=closed" target="blank">1.3.0</a></li>
</ul>
<li>17 February 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=8&amp;state=closed" target="blank">1.2.5</a></li>
</ul>
<li>10 February 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=7&amp;state=closed" target="blank">1.2.4</a></li>
</ul>
<li>4 February 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=6&amp;state=closed" target="blank">1.2.3</a></li>
</ul>
<li>31 January 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=5&amp;state=closed" target="blank">1.2.2</a></li>
</ul>
<li>15 January 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=3&amp;state=closed" target="blank">1.2.0</a></li>
</ul>
<li>14 January 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=2&amp;state=closed" target="blank">1.1.0</a></li>
</ul>
<li>13 January 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=4&amp;state=closed" target="blank">1.0.1</a></li>
</ul>
<li>12 January 2014</li>
<ul class="star">
<li><a href="https://github.com/alvarosanchez/grails-spring-security-rest/issues?milestone=1&amp;state=closed" target="blank">1.0.0</a></li>
</ul>
<li>10 January 2014</li>
<ul class="star">
<li>1.0.0.RC2</li>
</ul>
<li>31 December 2013</li>
<ul class="star">
<li>Initial 1.0.0.RC1 release.</li>
</ul></ul><p class="paragraph"/>


<h1 id="whatsNew14">2 What's new in 1.4?</h1>
<h2>Full compatibility with Spring Security core.</h2><p class="paragraph"/>Up to previous releases, this plugin was overriding "stateful" Spring Security core beans, to ensure a stateless behaviour.
After some users reported issues integrating this plugin with existing installations, version 1.4 now follows a more
friendly approach.<p class="paragraph"/>A <a href="../guide/single.html#configuration" class="guide">new chapter</a> has been created explaining how to configure the filter chains appropriately.<p class="paragraph"/><h2>RFC 6750 Bearer Token support by default</h2><p class="paragraph"/>Now, the token validation and rendering aligns with the <a href="http://tools.ietf.org/html/rfc6750" target="blank">RFC 6750 Bearer Token</a> spec.
If you want to keep the old behaviour, simply disable it by setting
<code>grails.plugin.springsecurity.rest.token.validation.useBearerToken = false</code><p class="paragraph"/><h2>Credentials are extracted from JSON by default</h2><p class="paragraph"/>It makes more sense in a REST application. The old behaviour can still be used by using the corresponding configuration
property.<p class="paragraph"/><h2>Anonymous access is allowed</h2><p class="paragraph"/>In case you want to enable anonymous access (read: not authenticated) to certain URL patterns, you can do so. Take a
look at the <a href="../guide/single.html#tokenValidation" class="guide">new chapter in the documentation</a>.<p class="paragraph"/><h2>Other minor changes</h2>
<ul class="star">
<li>Upgraded dependencies:</li>
<ul class="star">
<li><code>spring-security-core:2.0-RC3</code>.</li>
<li><code>cors:1.1.6</code>.</li>
</ul></ul><p class="paragraph"/>


<h1 id="configuration">3 Configuration</h1>
Once the plugin is installed, the minimum configuration is to select what <a href="../guide/single.html#tokenStorage" class="guide">token storage</a> strategy
do you want to use:
<ol>
<li><a href="../guide/single.html#grailsCache" class="guide">Grails Cache</a>.</li>
<li><a href="../guide/single.html#memcached" class="guide">Memcached</a></li>
<li><a href="../guide/single.html#gorm" class="guide">GORM</a>.</li>
<li>Provide your own: implement <a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/storage/TokenStorageService.html" target="blank">TokenStorageService</a> and register it in <code>resources.groovy</code> as <code>tokenStorageService</code></li>
</ol><p class="paragraph"/>All the other features can be used out-of-the-box with the default values, but please make sure you read the entire
plugin documentation to understand how they work and how can they be configured.<p class="paragraph"/><h2>Plugin configuration</h2><p class="paragraph"/><blockquote class="note">
This plugin depends on <a href="http://grails-plugins.github.io/grails-spring-security-core/docs/manual/guide/newInV2.html" target="blank">Spring Security Core 2.x</a>.
Make sure your application is compatible with that version first.
</blockquote><p class="paragraph"/>This plugin is compatible by default with Spring Security core traditional, form-based authentication. The important thing
to remember is: you have to separate the filter chains, so different filters are applied on each case.<p class="paragraph"/>The stateless, token-based approach of this plugin is incompatible with the HTTP session-based approach of Spring Security,
core, so the trick is to identify what URL patterns have to be stateless, and what others have to be stateful (if any).<p class="paragraph"/>To configure the chains properly, you can use the <code>grails.plugin.springsecurity.filterChain.chainMap</code> property:<p class="paragraph"/><div class="code"><pre>grails.plugin.springsecurity.filterChain.chainMap = &#91;
    '/api/&#42;&#42;': 'JOINED_FILTERS,&#45;exceptionTranslationFilter,&#45;authenticationProcessingFilter,&#45;securityContextPersistenceFilter',  // Stateless chain
    '/&#42;&#42;': 'JOINED_FILTERS,&#45;restTokenValidationFilter,&#45;restExceptionTranslationFilter'                                          // Traditional chain
&#93;</pre></div><p class="paragraph"/>To understand this syntax, please read the
<a href="http://grails-plugins.github.io/grails-spring-security-core/guide/filters.html" target="blank">Spring Security Core documentation</a>.
Long story short: <code>JOINED_FILTERS</code> refers to all the configured filters. The minus (<code>-</code>) notation means all the previous values
but the neglected one.<p class="paragraph"/>So the first chain applies all the filters except the stateful ones. The second one applies all the filters but the stateless ones.<p class="paragraph"/><blockquote class="note">
Make sure that the stateless chain applies not only to your REST controllers, but also to the URL's where this plugin
filters are listening: by default, <code>/api/login</code> for <a href="../guide/single.html#authentication" class="guide">authentication</a>, <code>/api/logout</code> for
<a href="../guide/single.html#authentication" class="guide">logout</a> and <code>/api/validate</code> for <a href="../guide/single.html#tokenValidation" class="guide">token validation</a>.
</blockquote><p class="paragraph"/>The difference is that, in a traditional form-based authentication, Spring Security will respond with an HTTP 302 redirect
to the login controller. That doesn't work for an API, so in the stateless approach, an HTTP 401 response will be sent back.


<h1 id="authentication">4 Authentication Endpoint</h1>
The <a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/RestAuthenticationFilter.html" target="blank">authentication filter</a>
uses the default <code>authenticationManager</code> bean, which in turn uses all the registered authentication
providers. See the <a href="http://grails-plugins.github.io/grails-spring-security-core/docs/manual/guide/authenticationProviders.html" target="blank">Spring Security Core guide</a>
for more information about how to define your own providers. Note that you can easily plug any Spring Security sub-plugin
(like the LDAP one) to use a different authentication strategy.<p class="paragraph"/>If the authentication is successful, a <a href="../guide/single.html#tokenGeneration" class="guide">token generator</a> is used to generate a token, and a
<a href="../guide/single.html#tokenStorage" class="guide">token storage</a> implementation is used to store the token. Finally, the JSON response sent back to the
client is rendered by a <code>restAuthenticationTokenJsonRenderer</code> bean. See the <a href="../guide/single.html#tokenRendering" class="guide">token rendering documentation</a>
for more details.<p class="paragraph"/><blockquote class="note">
This authentication filter will only be applied to the above configured URL and can also be disabled, in case a different approach
for token creation is followed. In the rest of the cases, the request will continue through the filter chain, reaching Spring Security
Core filters. Bear in mind that, by default, Spring Security Core 2.x locks down all URL's unless a explicit securiy rule has been
specified for each of them.<p class="paragraph"/>See <a href="http://grails-plugins.github.io/grails-spring-security-core/docs/manual/guide/single.html#requestMappings" target="blank">Spring Security Core documentation</a>
for more information.
</blockquote><p class="paragraph"/>The following are the <code>Config.groovy</code> properties available:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.active</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.login.endpointUrl</code></td><td><code>/api/login</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.failureStatusCode</code></td><td><code>401</code></td></tr></table><p class="paragraph"/><h2>Extracting credentials from the request</h2><p class="paragraph"/>The plugin supports 2 ways of extracting the username and password: using request parameters, and using a JSON payload.
To align with the RESTful principles, JSON payload is the default behaviour.<p class="paragraph"/><h3>From a JSON request</h3><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.useJsonCredentials</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.login.usernamePropertyName</code></td><td><code>username</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.passwordPropertyName</code></td><td><code>password</code></td></tr></table><p class="paragraph"/>
The default implementation expects a request like this:<p class="paragraph"/><div class="code"><pre>&#123;
    <span class="java&#45;quote">"username"</span>: <span class="java&#45;quote">"john.doe"</span>,
    <span class="java&#45;quote">"password"</span>: <span class="java&#45;quote">"dontTellAnybody"</span>
&#125;</pre></div><p class="paragraph"/>If you use <code>usernamePropertyName</code> and <code>passwordPropertyName</code> properties mentioned above, your JSON request can look like:<p class="paragraph"/><div class="code"><pre>&#123;
    <span class="java&#45;quote">"login"</span>: <span class="java&#45;quote">"john.doe"</span>,
    <span class="java&#45;quote">"pwd"</span>: <span class="java&#45;quote">"dontTellAnybody"</span>
&#125;</pre></div><p class="paragraph"/>With the following config:<p class="paragraph"/><div class="code"><pre>grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.login.usernamePropertyName = 'login'
grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.login.passwordPropertyName = 'pwd'</pre></div><p class="paragraph"/>If your JSON request format is different, you can plug your own implementation by defining a class which extends
<code><a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/AbstractJsonPayloadCredentialsExtractor.html" target="blank">AbstractJsonPayloadCredentialsExtractor</a></code>.
The default implementation looks like this:<p class="paragraph"/><div class="code"><pre>@Slf4j
class DefaultJsonPayloadCredentialsExtractor <span class="java&#45;keyword">extends</span> AbstractJsonPayloadCredentialsExtractor &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> usernamePropertyName
    <span class="java&#45;object">String</span> passwordPropertyName<p class="paragraph"/>    UsernamePasswordAuthenticationToken extractCredentials(HttpServletRequest httpServletRequest) &#123;
        def jsonBody = getJsonBody(httpServletRequest)<p class="paragraph"/>        <span class="java&#45;object">String</span> username = jsonBody.<span class="java&#45;quote">"$&#123;usernamePropertyName&#125;"</span>
        <span class="java&#45;object">String</span> password = jsonBody.<span class="java&#45;quote">"$&#123;passwordPropertyName&#125;"</span><p class="paragraph"/>        log.debug <span class="java&#45;quote">"Extracted credentials from JSON payload. Username: $&#123;username&#125;, password: $&#123;password?.size()?'&#91;PROTECTED&#93;':'&#91;MISSING&#93;'&#125;"</span><p class="paragraph"/>        <span class="java&#45;keyword">new</span> UsernamePasswordAuthenticationToken(username, password)
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Once you are done, register it in <code>resources.groovy</code> with the name <code>credentialsExtractor</code>.<p class="paragraph"/><h3>From request parameters</h3><p class="paragraph"/>Note that the name of the parameters can also be customised:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.useRequestParamsCredentials</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.login.usernamePropertyName</code></td><td><code>username</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.login.passwordPropertyName</code></td><td><code>password</code></td></tr></table>


<h2 id="logout">4.1 Logout Endpoint</h2>
The <a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/RestLogoutFilter.html" target="blank">logout filter</a>
exposes an endpoint for deleting tokens. It will read the token from an HTTP header. If found, will delete it from the
storage, sending a 200 response. Otherwise, it will send a 404 response.<p class="paragraph"/>You can configure it in <code>Config.groovy</code> using this properties:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.logout.endpointUrl</code></td><td><code>/api/logout</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.validation.headerName</code></td><td><code>X-Auth-Token</code></td></tr></table>



<h1 id="tokenGeneration">5 Token Generation</h1>
The plugin comes prepackaged with 2 token generation strategies:
<ul class="star">
<li><a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/generation/SecureRandomTokenGenerator.html" target="blank">Using java.security.SecureRandom</a>.</li>
<li><a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/generation/UUIDTokenGenerator.html" target="blank">Using java.util.UUID</a>.</li>
</ul><p class="paragraph"/>The strategy used is configurable in <code>Config.groovy</code>:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.generation.useSecureRandom</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.generation.useUUID</code></td><td><code>false</code></td></tr></table><p class="paragraph"/>Both of them generate tokens of 32 alphanumeric characters.<p class="paragraph"/>That should be enough for most of the human beings. But if you still want to provide your own implementation,
simply write a class implementing
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/generation/TokenGenerator.html" target="blank">TokenGenerator</a>
and wire it up in <code>resources.groovy</code> as <code>tokenGenerator</code>.


<h1 id="tokenStorage">6 Token Storage</h1>
The tokens are stored on the server using a <code>tokenStorageService</code> bean. The plugin comes with out-of-the-box support
for Memcached, GORM and <a href="http://grails.org/plugin/cache" target="blank">Grails Cache</a>, but you can use your own strategy implementing the
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/storage/TokenStorageService.html" target="blank">TokenStorageService</a>
interface.


<h2 id="memcached">6.1 Memcached</h2>
To use Memcached, simply define the following configuration properties to match your environments accordingly:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useMemcached</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.hosts</code></td><td><code>localhost:11211</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.username</code></td><td><code>''</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.password</code></td><td><code>''</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.memcached.expiration</code></td><td><code>3600</code></td></tr></table><p class="paragraph"/>For development, if you have Memcached installed locally with the default settings, just define
<code>grails.plugin.springsecurity.rest.token.storage.useMemcached = true</code>. It should work.


<h2 id="gorm">6.2 GORM</h2>
To use GORM, those are the relevant configuration properties:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useGorm</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.tokenDomainClassName</code></td><td><code>null</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.tokenValuePropertyName</code></td><td><code>tokenValue</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.gorm.usernamePropertyName</code></td><td><code>username</code></td></tr></table><p class="paragraph"/><blockquote class="note">
Please note that for <code>tokenDomainClassName</code> you must enter a fully qualified class name.
</blockquote><p class="paragraph"/>The domain class should look like this:<p class="paragraph"/><div class="code"><pre>class AuthenticationToken &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> tokenValue
    <span class="java&#45;object">String</span> username
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
In this case, instead of storing the whole <code>UserDetails</code> object, only the username is stored. This is because applications
using this strategy will probably have the standard User and Role domain classes. Then, the username is passed to the
default <code>userDetailsService</code> bean, which in the case of the default Spring Security Core GORM implementation will fetch
the information from the mentioned domain classes.
</blockquote>


<h2 id="grailsCache">6.3 Grails Cache</h2>
To use <a href="http://grails.org/plugin/cache" target="blank">Grails Cache</a>, simply define a cache name:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.storage.useGrailsCache</code></td><td><code>false</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.storage.grailsCacheName</code></td><td><code>null</code></td></tr></table><p class="paragraph"/>The cache name should correspond to a name specified in the <a href="http://grails-plugins.github.io/grails-cache/docs/manual/guide/usage.html#dsl" target="blank">cache DSL</a>.<p class="paragraph"/><blockquote class="note">
<strong class="bold">Token expiration / eviction / TTL</strong><p class="paragraph"/>By default, Spring Cache abstraction
<a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/cache.html#cache-specific-config" target="blank">does not support expiration</a>.
It depends on the specific support of the actual providers. Grails has several plugins for this:
<ul class="star">
<li><a href="http://grails-plugins.github.io/grails-cache/guide/usage.html#dsl" target="blank">Core</a>: unsupported.</li>
<li><a href="http://grails-plugins.github.io/grails-cache-ehcache/guide/usage.html#dsl" target="blank">Ehcache</a>: supported.</li>
<li><a href="http://grails-plugins.github.io/grails-cache-redis/guide/usage.html#dsl" target="blank">Redis</a>: unsupported.</li>
<li><a href="http://grails.org/plugin/cache-gemfire" target="blank">Gemfire</a>: unsupported.</li>
</ul><p class="paragraph"/></blockquote>



<h1 id="tokenRendering">7 Token Rendering</h1>
By default, this plugin renders the token in <a href="http://tools.ietf.org/html/rfc6750" target="blank">RFC 6750 Bearer Token</a> format:<p class="paragraph"/><div class="code"><pre>HTTP/1.1 200 OK
Content&#45;Type: application/json;charset=UTF&#45;8
Cache&#45;Control: no&#45;store
Pragma: no&#45;cache<p class="paragraph"/>&#123;
    <span class="java&#45;quote">"access_token"</span>:<span class="java&#45;quote">"3bicek1gc63oai6tfjkhog4kqn8ojd6a"</span>,
    <span class="java&#45;quote">"token_type"</span>:<span class="java&#45;quote">"Bearer"</span>,
    <span class="java&#45;quote">"username"</span>: <span class="java&#45;quote">"john.doe"</span>,
    <span class="java&#45;quote">"roles"</span>: &#91;
        <span class="java&#45;quote">"ROLE_ADMIN"</span>,
        <span class="java&#45;quote">"ROLE_USER"</span>
    &#93;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
As per the RFC, <code>access_token</code> and <code>token_type</code> property names cannot be customised.
</blockquote><p class="paragraph"/>The JSON structure can be customised with the following configuration keys:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.rendering.usernamePropertyName</code></td><td><code>username</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.rendering.authoritiesPropertyName</code></td><td><code>roles</code></td></tr></table><p class="paragraph"/>Eg, with the following configuration:<p class="paragraph"/><div class="code"><pre>grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.token.rendering.usernamePropertyName = 'login'
grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.token.rendering.authoritiesPropertyName = 'permissions'</pre></div><p class="paragraph"/>The output will look like:<p class="paragraph"/><div class="code"><pre>&#123;
    <span class="java&#45;quote">"access_token"</span>:<span class="java&#45;quote">"3bicek1gc63oai6tfjkhog4kqn8ojd6a"</span>,
    <span class="java&#45;quote">"token_type"</span>:<span class="java&#45;quote">"Bearer"</span>,
    <span class="java&#45;quote">"login"</span>: <span class="java&#45;quote">"john.doe"</span>,
    <span class="java&#45;quote">"permissions"</span>: &#91;
        <span class="java&#45;quote">"ROLE_ADMIN"</span>,
        <span class="java&#45;quote">"ROLE_USER"</span>
    &#93;
&#125;</pre></div><p class="paragraph"/><h2>Disabling bearer tokens support for full response customisation</h2><p class="paragraph"/>In order to fully customise the response, you need first to disable bearer tokens support by setting
<code>grails.plugin.springsecurity.rest.token.validation.useBearerToken = false</code>. That will enable you to use this additional
property:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.rendering.tokenPropertyName</code></td><td><code>access_token</code></td></tr></table><p class="paragraph"/><blockquote class="warning">
Disabling bearer token support impacts the way tokens are extracted from the HTTP request. Please, read carefully
<a href="../guide/single.html#tokenValidation" class="guide">the chapter about token validation</a> first.
</blockquote><p class="paragraph"/>If you want your own implementation, simply create a class implementing
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/token/rendering/RestAuthenticationTokenJsonRenderer.html" target="blank">RestAuthenticationTokenJsonRenderer</a>
and wire it up in <code>resources.groovy</code> with name <code>restAuthenticationTokenJsonRenderer</code>.<p class="paragraph"/><blockquote class="note">
The principal object stored in the security context, and passed to the JSON renderer, is coming from the configured
authentication providers. In most cases, this will be a <code>UserDetails</code> object retrieved using the <code>userDetailsService</code> bean.
If you want to render additional information in your JSON response, you have to:
<ol>
<li>Configure an alternative <code>userDetailsService</code> bean that retrieves the additional information you want, and put it in a principal object.</li>
<li>Configure an alternative <code>restAuthenticationTokenJsonRenderer</code> that reads that information from the <code>restAuthenticationToken.principal</code> object.</li>
</ol><p class="paragraph"/></blockquote>


<h1 id="tokenValidation">8 Token Validation Filter</h1>
The token validation filter looks for the token in the request and then tries to validate it using the configured
<a href="../guide/single.html#tokenStorage" class="guide">token storage</a> implementation.<p class="paragraph"/>If the validation is successful, the principal object is stored in the security context. This allows you to use in
your application <code>&#64;Secured</code>, <code>springSecurityService.principal</code> and so on.<p class="paragraph"/><blockquote class="note">
<code>springSecurityService.currentUser</code> expects a <code>grails.plugin.springsecurity.userdetails.GrailsUser</code> to perform a DB query.
However, this plugins stores in the security context just a principal <code>Object</code>, because it does not assume you are using
domain classes to store the users. Use <code>springSecurityService.principal</code> instead.
</blockquote><p class="paragraph"/>This plugin supports <a href="http://tools.ietf.org/html/rfc6750" target="blank">RFC 6750 Bearer Token</a> specification out-of-the-box.<p class="paragraph"/><h2>Sending tokens in the request</h2><p class="paragraph"/>The token can be sent in the <code>Authorization</code> request reader:<p class="paragraph"/><div class="code"><pre>GET /protectedResource HTTP/1.1
Host: server.example.com
Authorization: Bearer 3bicek1gc63oai6tfjkhog4kqn8ojd6a</pre></div><p class="paragraph"/>Or using form-encoded body parameters:<p class="paragraph"/><div class="code"><pre>POST /protectedResource HTTP/1.1
Host: server.example.com
Content&#45;Type: application/x&#45;www&#45;form&#45;urlencoded<p class="paragraph"/>access_token=3bicek1gc63oai6tfjkhog4kqn8ojd6a</pre></div><p class="paragraph"/>Note that in this case, <code>GET</code> HTTP method is not supported.<p class="paragraph"/>If you disable the bearer token support, you can customise it further:<p class="paragraph"/><div class="code"><pre>grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.token.validation.useBearerToken = <span class="java&#45;keyword">false</span>
grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.token.validation.headerName = 'X&#45;Auth&#45;Token'</pre></div><p class="paragraph"/>If you still want to have full access and read the token from a different part of the request, you can implement a
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/TokenReader.html" target="blank">TokenReader</a>
and register it in your <code>resources.groovy</code>  as <code>tokenReader</code>.<p class="paragraph"/><h2>Anonymous access</h2><p class="paragraph"/>If you want to enable anonymous access to URL's where this plugin's filters are applied, you need to:
<ol>
<li>Configure <code>enableAnonymousAccess = true</code> (see table below).</li>
<li>Make sure that the <code>anonymousAuthenticationFilter</code> is applied before <code>restTokenValidationFilter</code>. See <a href="../guide/single.html#configuration" class="guide">how to configure filters</a> for more details.</li>
</ol><p class="paragraph"/>For example, with this configuration:<p class="paragraph"/><div class="code"><pre>grails &#123;
    plugin &#123;
        springsecurity &#123;
            filterChain &#123;
                chainMap = &#91;
                    '/api/guest/&#42;&#42;': 'anonymousAuthenticationFilter,restTokenValidationFilter,restExceptionTranslationFilter,filterInvocationInterceptor',
                    '/api/&#42;&#42;': 'JOINED_FILTERS,&#45;anonymousAuthenticationFilter,&#45;exceptionTranslationFilter,&#45;authenticationProcessingFilter,&#45;securityContextPersistenceFilter',
                    '/&#42;&#42;': 'JOINED_FILTERS,&#45;restTokenValidationFilter,&#45;restExceptionTranslationFilter'
                &#93;
            &#125;<p class="paragraph"/>            //Other Spring Security settings
            //...<p class="paragraph"/>            <span class="java&#45;keyword">rest</span> &#123;
                token &#123;
                    validation &#123;
                        enableAnonymousAccess = <span class="java&#45;keyword">true</span>
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>The following chains are configured:
<ol>
<li><code>/api/guest/&#42;*</code> is a stateless chain that allows anonymous access when no token is sent. If however a token is on the request, it will be validated.</li>
<li><code>/api/&#42;*</code> is a stateless chain that doesn't allow anonymous access. Thus, the token will always be required, and if missing, a Bad Request reponse will be sent back to the client.</li>
<li><code>/&#42;*</code> (read: everything else) is a traditional stateful chain.</li>
</ol><p class="paragraph"/><h2>Validation Endpoint</h2><p class="paragraph"/>There is also an endpoint available that you can call in case you want to know if a given token is valid. It looks for
the token in a HTTP header as well, and if the token is still valid, it renders <a href="../guide/single.html#authentication" class="guide">its JSON representation</a>.
If the token does not exist, it will render a <code>grails.plugin.springsecurity.rest.login.failureStatusCode</code> response
(<code>401</code> by default).<p class="paragraph"/>The relevant configuration properties for the validation endpoint are:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Config key</strong></th><th><strong class="bold">Default value</strong></th></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.validation.active</code></td><td><code>true</code></td></tr><tr class="table-even"><td><code>grails.plugin.springsecurity.rest.token.validation.headerName</code></td><td><code>X-Auth-Token</code></td></tr><tr class="table-odd"><td><code>grails.plugin.springsecurity.rest.token.validation.endpointUrl</code></td><td><code>/api/validate</code></td></tr></table>


<h1 id="cors">9 CORS support</h1>
This plugin comes pre-installed with the <a href="http://grails.org/plugin/cors" target="blank">CORS plugin</a>, which enables
<a href="http://www.w3.org/TR/cors/" target="blank">Cross-Origin Resource Sharing</a>. Refer to the
<a href="https://github.com/davidtinker/grails-cors/blob/master/README.md" target="blank">plugin documentation</a> to learn how to configure it.<p class="paragraph"/>The CORS plugin activates itself by default. If you don't want it for some environments, you can use
<code>cors.enabled = false</code> within the appropriate environment block in your <code>Config.groovy</code>.<p class="paragraph"/>If you don't want CORS support at all, you can skip the plugin by excluding it
when defining this plugin in your <code>BuildConfig.groovy</code>:<p class="paragraph"/><div class="code"><pre>compile ':spring&#45;security&#45;<span class="java&#45;keyword">rest</span>:&#123;&#123;VERSION&#125;&#125;', &#123;
    exclude 'cors
&#125;</pre></div>


<h1 id="oauth">10 Delegating authentication to OAuth providers</h1>
This plugin is meant to be used in applications serving a REST API's to pure Javascript clients. The main authentication
flow of this plugin is to allow you to authenticate your users against any Spring Security-compatible user directory
(like a DB or an LDAP server).<p class="paragraph"/>However, there might be situations where you want to delegate the authentication against a third-party provider, like
Google or Facebook. Unfortunately, your pure Javascript front-end application cannot request the providers directly using
OAuth, because then the access keys will be made public.<p class="paragraph"/>So is this plugin's responsibility to provide endpoints so your Grails backend acts as a proxy for your front-end client.<p class="paragraph"/>The flow is something like the following:<p class="paragraph"/><img border="0" class="center" src="../img/oauth.png"></img>
<ol>
<li>The client application requests and endpoint that requires authentication, so the server responds with a 401 response (*).</li>
<li>The client redirects the user to the login form (*).</li>
<li>This time, instead of using username and password, the user clicks on "Login with Google" button.</li>
<li>Browser navigates to a Grails URL. Grails will generate a Google Login URL, giving Google a Grails callback URL.</li>
<li>Browser navigates to Google Login. User logs in, and Google redirects the browser to the Grails callback URL.</li>
<li>Browser navigates to that Grails callback URL. Then, Grails will use OAuth to fetch user information (like email) from Google. Based on that, will generate a REST API token and fetch and store principal information. The response from Grails will be a front-end URL where the token is a parameter.</li>
<li>The browser will navigate to that URL, and the Javascript logic will read the token from the URL and store it locally.</li>
<li>The client sends again a request to the protected resource, passing the token as an HTTP header (*).</li>
</ol><p class="paragraph"/>The steps flagged with (*) remain unchanged from the <a href="../guide/single.html#authentication" class="guide">normal flow</a>.<p class="paragraph"/>To support OAuth, this plugin uses <a href="https://github.com/leleuj/pac4j" target="blank">Profile &#38; Authentication Client for Java</a>. So you
can use any OAuth 2.0 provider they support. This includes at the time of writing:
<ul class="star">
<li>Dropbox.</li>
<li>Facebook.</li>
<li>GitHub.</li>
<li>Google.</li>
<li>LinkedIn.</li>
<li>Twitter.</li>
<li>Windows Live.</li>
<li>Wordpress.</li>
<li>Yahoo.</li>
<li>Paypal.</li>
</ul><p class="paragraph"/><blockquote class="note">
Remember: only OAuth 2.0 providers are supported by this plugin at the moment.
</blockquote><p class="paragraph"/>To start the OAuth authentication flow, from your frontend application, generate a link to
<code>&#60;YOUR_GRAILS_APP&#62;/oauth/authenticate/&#60;provider&#62;</code>. The user clicking on that link represents step 4 in the previous
diagram.<p class="paragraph"/>Note that you can define the frontend callback URL in <code>Config.groovy</code> under
<code>grails.plugin.springsecurity.rest.oauth.frontendCallbackUrl</code>. You need to define a closure that will be called with
the token value as parameter:<p class="paragraph"/><div class="code"><pre>grails.plugin.springsecurity.<span class="java&#45;keyword">rest</span>.oauth.frontendCallbackUrl = &#123; <span class="java&#45;object">String</span> tokenValue &#45;&#62; <span class="java&#45;quote">"http://my.frontend&#45;app.com/welcome&#35;token=$&#123;tokenValue&#125;"</span> &#125;</pre></div><p class="paragraph"/>You can also define the URL as a <code>callback</code> parameter in the original link, eg:<p class="paragraph"/><div class="code"><pre>http://your&#45;grails&#45;api.com/oauth/authenticate/google?callback=http://your&#45;frontend&#45;app.com/auth&#45;success.html?token=</pre></div><p class="paragraph"/>In this case, the token will be <strong class="bold">concatenated</strong> to the end of the URL.<p class="paragraph"/>Upon successful OAuth authorisation (after step 6.1 in the above diagram), an
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/oauth/OauthUser.html" target="blank">OauthUser</a>
will be stored in the security context. This is done by a bean named <code>oauthUserDetailsService</code>. The
<a href="http://alvarosanchez.github.io/grails-spring-security-rest/docs/gapi/com/odobo/grails/plugin/springsecurity/rest/oauth/DefaultOauthUserDetailsService.html" target="blank">default implementation</a>
delegates to the configured <code>userDetailsService</code> bean, passing the profile ID as the username:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;
 &#42; Builds an &#123;<code>link OauthUser&#125;. Delegates to the <span class="java&#45;keyword">default</span> &#123;</code>link UserDetailsService&#35;loadUserByUsername(java.lang.<span class="java&#45;object">String</span>)&#125;
 &#42; where the username passed is &#123;@link UserProfile&#35;getId()&#125;. If the user is not found, it will create a <span class="java&#45;keyword">new</span> one with
 &#42; the the <span class="java&#45;keyword">default</span> roles.
 &#42;/
@Slf4j
class DefaultOauthUserDetailsService <span class="java&#45;keyword">implements</span> OauthUserDetailsService &#123;<p class="paragraph"/>    @Delegate
    UserDetailsService userDetailsService<p class="paragraph"/>    OauthUser loadUserByUserProfile(OAuth20Profile userProfile, Collection&#60;GrantedAuthority&#62; defaultRoles)
            <span class="java&#45;keyword">throws</span> UsernameNotFoundException &#123;
        UserDetails userDetails
        OauthUser oauthUser<p class="paragraph"/>        <span class="java&#45;keyword">try</span> &#123;
            log.debug <span class="java&#45;quote">"Trying to fetch user details <span class="java&#45;keyword">for</span> user profile: $&#123;userProfile&#125;"</span>
            userDetails = userDetailsService.loadUserByUsername userProfile.id
            Collection&#60;GrantedAuthority&#62; allRoles = userDetails.authorities + defaultRoles
            oauthUser = <span class="java&#45;keyword">new</span> OauthUser(userDetails.username, userDetails.password, allRoles, userProfile)
        &#125; <span class="java&#45;keyword">catch</span> (UsernameNotFoundException unfe) &#123;
            log.debug <span class="java&#45;quote">"User not found. Creating a <span class="java&#45;keyword">new</span> one with <span class="java&#45;keyword">default</span> roles: $&#123;defaultRoles&#125;"</span>
            oauthUser = <span class="java&#45;keyword">new</span> OauthUser(userProfile.id, 'N/A', defaultRoles, userProfile)
        &#125;
        <span class="java&#45;keyword">return</span> oauthUser
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>
If you want to provide your own implementation, define it in <code>resources.groovy</code> with bean name <code>oauthUserDetailsService</code>.
Make sure you implements the interface <code>OauthUserDetailsService</code><p class="paragraph"/>If you want to do any additional post-OAuth authorisation check, you should do it on your <code>loadUserByUserProfile</code>
implementation. This is useful if you want to allow your corporate users to log into your application using their Gmail
account. In this case, you should decide based on OAuth20Profile.getEmail(), for instance:<p class="paragraph"/><div class="code"><pre>OauthUser loadUserByUserProfile(OAuth20Profile userProfile, Collection&#60;GrantedAuthority&#62; defaultRoles) <span class="java&#45;keyword">throws</span> UsernameNotFoundException &#123;
    <span class="java&#45;keyword">if</span> (userProfile.email.endsWith('example.org')) &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> OauthUser(userProfile.id, 'N/A', defaultRoles, userProfile)
    &#125; <span class="java&#45;keyword">else</span> &#123;
        <span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> UsernameNotFoundException(<span class="java&#45;quote">"User with email $&#123;userProfile.email&#125; now allowed. Only @example.org accounts are allowed."</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>In case of any OAuth authentication failure, the plugin will redirect back to the frontend application anyway, so it
has a chance to render a proper error message and/or offer the user the option to try again. In that case, the token
parameter will be empty, and both <code>error</code> and <code>message</code> params will be appended:<p class="paragraph"/><div class="code"><pre>http://your&#45;frontend&#45;app.com/auth&#45;success.html?token=&#38;error=403&#38;message=User+with+email+jimmy%40gmail.com+now+allowed.+Only+%40example.com+accounts+are+allowed</pre></div><p class="paragraph"/>Below are some examples on how to configure it for Google, Facebook and Twitter.


<h2 id="google">10.1 Google</h2>
Define the following block in your <code>Config.groovy</code>:<p class="paragraph"/><div class="code"><pre>grails &#123;
    plugin &#123;
        springsecurity &#123;<p class="paragraph"/>            <span class="java&#45;keyword">rest</span> &#123;<p class="paragraph"/>                oauth &#123;<p class="paragraph"/>                    frontendCallbackUrl = &#123; <span class="java&#45;object">String</span> tokenValue &#45;&#62; <span class="java&#45;quote">"http://my.frontend&#45;app.com/welcome&#35;token=$&#123;tokenValue&#125;"</span> &#125;<p class="paragraph"/>                    google &#123;<p class="paragraph"/>                        client = org.pac4j.oauth.client.Google2Client
                        key = 'xxxx.apps.googleusercontent.com'
                        secret = 'xxx'
                        scope = org.pac4j.oauth.client.Google2Client.Google2Scope.EMAIL_AND_PROFILE
                        defaultRoles = &#91;'ROLE_USER', 'ROLE_GOOGLE'&#93;<p class="paragraph"/>                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="warning">
The <code>scope</code> can be from any value of the enum <code>org.pac4j.oauth.client.Google2Client.Google2Scope</code>. But if you use the
default <code>OauthUserDetailsService</code>, you need to use <code>EMAIL_AND_PROFILE</code>. That is because the default implementation
uses the profile ID as the username, and that is only returned by Google if <code>EMAIL_AND_PROFILE</code> scope is used.
</blockquote>



<h2 id="facebook">10.2 Facebook</h2>
Define the following block in your <code>Config.groovy</code>:<p class="paragraph"/><div class="code"><pre>grails &#123;
    plugin &#123;
        springsecurity &#123;<p class="paragraph"/>            <span class="java&#45;keyword">rest</span> &#123;<p class="paragraph"/>                oauth &#123;<p class="paragraph"/>                    frontendCallbackUrl = &#123; <span class="java&#45;object">String</span> tokenValue &#45;&#62; <span class="java&#45;quote">"http://my.frontend&#45;app.com/welcome&#35;token=$&#123;tokenValue&#125;"</span> &#125;<p class="paragraph"/>                    facebook &#123;<p class="paragraph"/>                        client = org.pac4j.oauth.client.FacebookClient
                        key = 'xxx'
                        secret = 'yyy'
                        scope = 'email,user_location'
                        fields = 'id,name,first_name,middle_name,last_name,username'
                        defaultRoles = &#91;'ROLE_USER', 'ROLE_FACEBOOK'&#93;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>The <code>scope</code> is a comma-separated list, <strong class="bold">without blanks</strong>, of Facebook permissions. See the
<a href="https://developers.facebook.com/docs/reference/login/" target="blank">Facebook documentation</a> for more details.<p class="paragraph"/><code>fields</code> may contain a comma-separated list, <strong class="bold">without blanks</strong>, of
<a href="https://developers.facebook.com/docs/graph-api/reference/user/" target="blank">user fields</a>.<p class="paragraph"/>Both <code>scope</code> and <code>fields</code> are optional, but it's highly recommendable to fine tune those lists so you don't ask for
information you don't need.


<h2 id="twitter">10.3 Twitter</h2>
Define the following block in your <code>Config.groovy</code>:<p class="paragraph"/><div class="code"><pre>grails &#123;
    plugin &#123;
        springsecurity &#123;<p class="paragraph"/>            <span class="java&#45;keyword">rest</span> &#123;<p class="paragraph"/>                oauth &#123;<p class="paragraph"/>                    frontendCallbackUrl = &#123; <span class="java&#45;object">String</span> tokenValue &#45;&#62; <span class="java&#45;quote">"http://my.frontend&#45;app.com/welcome&#35;token=$&#123;tokenValue&#125;"</span> &#125;<p class="paragraph"/>                    twitter &#123;<p class="paragraph"/>                        client = org.pac4j.oauth.client.TwitterClient
                        key = 'xxx'
                        secret = 'yyy'
                        defaultRoles = &#91;'ROLE_USER', 'ROLE_TWITTER'&#93;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>There is no additional configuration for Twitter.


<h1 id="debugging">11 Debugging</h1>
If you need debug information, you can specify the following entries in <code>Config.groovy</code>:<p class="paragraph"/><div class="code"><pre>log4j = &#123;
    ...<p class="paragraph"/>    debug  'com.odobo',
           'grails.app.controllers.com.odobo',
           'grails.app.services.com.odobo',
           'org.pac4j',
           'org.springframework.security'<p class="paragraph"/>    &#8230;
&#125;</pre></div><p class="paragraph"/><p class="paragraph"/>



<h1 id="faq">12 Frequently Asked Questions</h1>
<h2>Why this token-based implementation? Can't I use HTTP basic authentication?</h2><p class="paragraph"/>In theory you can. The only restriction to be truly stateless is to not use HTTP sessions at all. So if you go with
basic authentication, you need to transfer the credentials back and forth every time.<p class="paragraph"/>Let's think about that. Keep in mind that your frontend is a pure HTML/Javascript application, consuming a REST API
from the Grails side. So the first time, the Javascript application will make an API query and will receive a 401 response
indicating that authentication is required. Then you present the user a form to enter credentials, you grab them, <strong class="bold">encode</strong>
them with Base64 and in the next request, you send an HTTP header like <code>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</code>.<p class="paragraph"/>Now remember you are doing RESTful application, so the session state is maintained in the client. That means that you
would need to store that Base64 encoded string somewhere: cookies? HTML5 local storage? In any case, they are accessible
using browser tools. And that's the point: there is a huge security risk because Base64 it's not encryption, just encoding.
And it can be easily decoded.<p class="paragraph"/>You could argue that someone can access the token in the browser. Yes, but having the token will not allow him to obtain
user's credentials. The tokens are just not decodable. And they can be revoked if necessary.<p class="paragraph"/>Fortunately for you, a token-based solution is not a magic idea that I only got; it's actually a specification:
<a href="http://tools.ietf.org/html/rfc6750" target="blank">RFC 6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage</a>.<p class="paragraph"/>There is also more reasons to be in favour of tokens:
<ul class="star">
<li>With basic auth, every single API call would have to check credentials. In the token-based implementation, specially if you use Memcached, the authentication results are cached.</li>
<li>With basic auth, you are sending the credentials all the time. Ok, you can use SSL, but still I think it's more elegant to use tokens.</li>
</ul><p class="paragraph"/>Moreover, if you use tokens, you have the chance to implement expiration policies.<p class="paragraph"/>A couple of link with further explanations on the token-based flow:
<ul class="star">
<li><a href="http://www.jamesward.com/2013/05/13/securing-single-page-apps-and-rest-services" target="blank">http://www.jamesward.com/2013/05/13/securing-single-page-apps-and-rest-services</a></li>
<li><a href="http://blog.brunoscopelliti.com/authentication-to-a-restful-web-service-in-an-angularjs-web-app" target="blank">http://blog.brunoscopelliti.com/authentication-to-a-restful-web-service-in-an-angularjs-web-app</a></li>
</ul><p class="paragraph"/><h2>Why can't the API be secured with OAuth?</h2><p class="paragraph"/><a href="http://tools.ietf.org/html/rfc6749" target="blank">RFC 6749 - OAuth 2.0</a> specification does cover this scenario in what they call
"public clients":<p class="paragraph"/><div class="code"><pre>Clients incapable of maintaining the confidentiality of their credentials (e.g., clients executing on the device used by the
resource owner, such as an installed <span class="java&#45;keyword">native</span> application or a web browser&#45;based application), and incapable of secure client
authentication via any other means.</pre></div><p class="paragraph"/>Using OAuth, you would need to store consumer key and consumer secret in the browser. Seriously, you don't want
to do that. The problem with OAuth is that it's designed for when the consumer is a server-side application. And it just
does not work well with pure Javascript front-ends. In this scenario, your frontend would be the OAuth consumer and
your Grails backend the OAuth provider.<p class="paragraph"/>The OAuth 2.0 specification supports public clients with the implicit grant. This plugin supports that by default when
you <a href="../guide/single.html#oauth" class="guide">delegate the authentication to another OAuth provider</a>. If it's you who are authenticating the users
(via DB, LDAP, etc), the token-based flow of this plugin is  <em class="italic">OAuth-ish</em> .<p class="paragraph"/><h2>Why you didn't use any of the existing OAuth plugins? Why pac4j?</h2><p class="paragraph"/>I'm aware of plugins like <a href="http://grails.org/plugin/oauth" target="blank">OAuth</a> and
<a href="http://grails.org/plugin/spring-security-oauth" target="blank">Spring Security OAuth</a>, but all of them rely on Spring Security Core's
way of using HTTP sessions. So not acceptable.<p class="paragraph"/>I chose pac4j because:
<ol>
<li>They support major OAuth 2.0 providers out-of-the-box, whereas Scribe does not.</li>
<li>It's deadly simple and works just fine.</li>
</ol><p class="paragraph"/>I'm also aware of a pac4j-spring-security module. See my previous response on HTTP sessions.<p class="paragraph"/><h2>Dude, this is awesome. How can I compensate you?</h2><p class="paragraph"/>I doubt you can :). You may try giving me free beers the next time you see me in a conference. Or you can just express
your gratitude via <a href="https://twitter.com/alvaro_sanchez" target="blank">Twitter</a>.

                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
